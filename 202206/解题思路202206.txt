1.两数和，twoSum
数据结构：哈希表
思路：空间换时间，哈希表存储过去遇到的数字，当遇到新数时，查看”差值“是否在哈希表中

拓展1：15.threeSum，三数和
思路：多一层循环先定一个数，将三数和问题转化成两数和，此时发现时间复杂度为O(n^2)
于是，直接先对数组预排序，然后定一个数，问题转化成有序数组的两数和，使用双指针查找即可，节省O(n)的哈希表存储空间。

其他拓展：组合总和；路径和

2.两数相加，addTwoNumbers
数据结构：链表
算法：迭代或递归
思路：链表相加，维护进位数即可

3.无重复字符最长子串，lengthOfLongestSubstring
数据结构：哈希表 + 单指针
思路：哈希表记录每个字符最新的位置，单指针负责计算无重复字符串的起点

4.排序数组的中位数，findMedianSortedArrays
数据结构：数组 + 单指针
算法：二分查找 + 递归
思路：本质是找第K大的数，使用累次剔除劣策略。因为在两个数组中找，因此需要每个数组先比较第k/2个，把无效的部分排除，最后到达边界时返回结果。边界条件：
（1）一个数组被完全排除，直接取第二个数组；
（2）k = 1，那就是两个数组中找最小的那个数

5.最长回文子串，longestPalindrom
数据结构：双指针
算法：中心展开法

8.字符串转数字，myAtoi
数据结构：字符串 + 哈希表
算法：有限状态机
思路：字符有四种状态”空格、符号、数字、其他“，构建状态转移表，表示各种状态之间的转移关系，相当于写了很多if else语句。当遇到新的字符时，根据上一个状态计算其转移状态，不同状态对应不同的动作，比如数字加和，符号识别，或者结束。

10.正则表达式匹配，isMatch
算法：递归dfs
'.' 匹配任意字符
'*' 匹配0次或1次（即多次）
边界条件：指针越界问题

11.盛水最多的容器，maxArea
数据结构：双指针
算法：累次剔除劣策略，比较两个指针的大小，删除无效解空间（对比暴力解法而言）

13.罗马数字转整数，romanToInt
数据结构：哈希表
算法：按照编码表规则实现即可

14.最长公共前缀
数据结构：字符串
算法：迭代遍历每个字符判定公共性，不是则返回结果

15.三数之和，threeSum
数据结构：哈希表，或，双指针
算法：预排序，定一个数字，将问题转化成两数之和

17.电话号码的字母组合，letterCombinations
数据结构：哈希表存储数字字母映射，队列queue
算法：宽度优先遍历（数据结构队列），深度优先遍历dfs

19.删除链表的倒数第n个节点，removeNthFromEnd
数据结构：快慢指针
算法：构造哑结点，避免链表被完全删除，而找不到前后节点

20.有效括号数，isValid
数据结构：计数器，or，栈stack
算法：
算法1：通过左右括号计数器，当有括号数大于左括号数时，返回false，最后比较左右括号数是否相等
算法2：栈，通过栈维持左括号和匹配消除左括号，当遇到有括号，而栈空无法匹配时返回false，最后判定栈是否为空，即是否完全匹配。
扩展：22.括号生成

21.合并两个有序链表，MergeTwoLists
数据结构：双指针
算法：遍历

22.括号生成，generateParentheses
数据结构：计数器
算法：深度优先遍历dfs
思路：左右括号计数器，当left < n时可以加左括号'('，当right < left时，可以加有括号')'

23.合并K个升序链表，mergeKLists
数据结构：双指针
算法：二分归并（分治算法）
思路：先实现一个合并两个链表的算法，通过二分归并分治合并

31.下一个排列，nextPermutation
数据结构：单调指针
算法：迭代
思路：用单调指针寻找待更新的数字，找到后与后面第一个刚好大于它的数互换，最后将后面的数字全部逆序，即是下一个排列（即一个位置进1，后续位置从小到大排列）

32.最长有效括号数，longestValidParentheses
数据结果：计数器 or 栈 or 数组
算法：
算法1：左右括号计数器，当有括号大于左括号时，计数器清零，当左右括号数相等时，记录有效括号长度
算法2：栈，维持括号的左边界，初始时放入-1，遇到右括号时匹配弹出栈顶左括号下标，同时记录有效括号数。
如果此时栈为空，就把下标i入栈表示新的左边界。
算法3：动态规划，左括号时dp[i] = 0，有括号时需要判定是否有左括号与之相匹配，同时加上匹配左括号前面已经匹配了的括号。


33.搜索旋转排序数组，search
数据结构：数组
算法：二分法，在连续的空间里进行二分查找

34.在排序数组中查找元素的第一个和最后一个位置，searchRange
数据结构：
算法：二分法，第一个mid =（left+right) >> 1，最后一个mid =（left+right+1)>>1;

39.组合总和，combinationSum
数据结构：数组
算法：深度优先遍历dfs
思路：每次选择或不选择，当index = size时判断tsum是否等于target，放入结果集中

42.接雨水，trap
数据结构：单调递减栈
算法：
算法1：单调递减栈维持洼地的左边界，遇到右边界时记录洼地的”底“，然后弹出左边界，计算面积
算法2：动态规划，计算左右两边的高峰，然后计算当前位置”洼柱“的面积

46.全排列，permute
数据结构：状态数组
算法：深度优先遍历
思路：维持一个数字被选择的状态表，递归选择其中一个数字，当选择结束时放入结果集中

48.旋转图像，rotate
数据结构：二维数组
算法：先对角翻转，再水平翻转，即等效于顺时针旋转

49.字母异位词分组，groupAnagrams
数据结构：哈希表
算法：将每个字母异位词排序或某种哈希，即可进行分组

53.最大数组和，maxSubArray
数据结构：数组
算法：动态规划
思路：记录当前位置最大和，当前一个位置和小于0，重新计数，即dp[i] = nums[i]

55.跳跃游戏，canJump
数据结构：数组
算法：动态规划
思路：记录每个位置能跳跃的最远距离，并且记录全局能跳跃的最远距离，当最远距离到达n-1时，直接返回true，当最远距离还达不到当前位置则返回false

56.合并区间，merge
数据结构：二维数组
算法：迭代
思路：先对二维数组按区间左边界进行预排序，遍历，当左边界大于结果集最后一个区间的右边界时，放入新的结果，否则更新最后一个区间的右边界

62.不同路径，uniquePaths
数据结构：二维数组
算法：动态规划，转移方程dp[i][j] = dp[i-1][j] + dp[i][j-1]

64.最小路径和，minPathSum
数据结构：二维数组
算法：动态规划
思路：每次选择最小的路径，等价于结果最小的路径

70.爬楼梯，climbStairs
数据结构：f1,f2
算法：动态规划
思路：斐波那契数列

72.编辑距离，minDistance
数据结构：数组
算法：动态规划
思路：增、删、改，三种编辑可能

75.颜色分类，sortColors
数据结构：双指针
算法：双指针，先排2，再排0

76.最小覆盖子串，minWindow
数据结构：哈希表，双指针
算法：在匹配的情况下，逐步右移左边界，寻找更小的覆盖区间

78.子集，subsets
数据结构：队列queue，数组
算法：宽度优先算法bfs or 深度优先遍历dfs
思路1：一层一层的处理
思路2：选或者不选，当i = size时放入结果集（注意与全排列的不同之处）

79.单词搜索，exist
数据结构：二维数组状态表
算法：深度优先遍历dfs
思路：从一个位置为起点深度遍历，不得重复遍历（设置状态位）

[重点]
84.柱状图中最大的矩形，largestRectangleArea
数据结构：单调递增栈 + 数组
算法：单调递增栈计算柱子i的左右边界
思路：
第一步：单调递增栈从左到右计算左边界；
第二步：单调递增栈从右到左计算右边界
第三步：根据左右边界计算矩形面积

94.二叉树中序遍历，inorderTraversal
数据结构：栈 or 单指针
算法：迭代法 or 深度优先遍历 or 前一个指针迭代法
思路：
方法一：用栈维持二叉树节点的前后顺序，迭代遍历
方法二：用dfs算法按序递归调用
方法三：用前一个指针

96.不同的二叉搜索树，numTrees
数据结构：数组
算法：动态规划
思路：根据二叉搜索树的特性，将问题拆分成子问题处理，即G[n] = sum(F(i, n))

98.验证二叉搜索树，isValidBST
数据结构：栈
算法：迭代法 or 深度优先遍历dfs
思路1：迭代法，二叉树的中序遍历，比较节点是否递增
思路2：深度优先遍历dfs，递归调用时通过父亲节点更新孩子节点的左右边界，判断是否合法

101.对称二叉树，isSymmetric
数据结构：队列 or 栈
算法：宽度优先遍历bfs or 深度优先遍历dfs
思路1：bfs，每次将左右子树压入队列，每次弹出两个节点进行比较
思路2：dfs，递归调用比较左右子树是否相等。

102.二叉树的层序遍历，levelOrder
数据结构：队列
算法：宽度优先遍历

103.二叉树之字型遍历，zigzagLevelOrder
数据结构：队列
算法：宽度优先遍历
思路：同102题层序遍历，只不过偶数层需要逆序遍历

104.二叉树的最大深度，maxDepth
数据结构：队列 or 递归调用栈
算法：宽度优先遍历 or 深度优先遍历
思路1：bfs，层序遍历
思路2：dfs，递归调用

105.从前序遍历和中序遍历中构建二叉树，buildTree
数据结构：数组，二叉树
算法：贪心算法
思路：从前序遍历确定根节点，再从中序遍历中确定左右子树

108.有序数组转平衡二叉搜索树，sortedArrayToBST
算法：深度优先遍历
思路：二分构造根节点，递归构造左右子树，返回根节点

114.二叉树展开为链表，flatten
数据结构：二叉树
算法：二叉树的前一个节点
思路：利用二叉树的前一个节点将二叉树转变成链表

116.填充每个节点的下一个右侧节点指针
数据结构：队列
算法：宽度优先搜索
思路：通过层序遍历，建立水平方向上的右侧节点指针

118.杨辉三角，generate
数据结构：数组
算法：迭代
思路：因为杨辉三角每一层的数字只依赖于上一层的数字，因此可以通过迭代实现。

121.买卖股票的最佳时机，maxProfit
数据结构：数组
算法：动态规划
思路：在最便宜的时候买，之后在最贵的时候卖
tips：只买卖一次

122.买卖股票的最佳时机2，maxProfit
数据结构：数组
算法：动态规划 or 贪心算法
思路1：股民只有两种状态：持有股票或持有现金，可以通过动态规划，记录每个时刻持有股票或持有现金的最大收益，最后时刻手中拥有的现金就是最大收益
思路2：进一步把股价趋势图画出来，可以看到，股民只要在每一次涨价都卖出股票，那它的收益肯定是最大化的，即res += (prices[i] - prices[i-1])
tips：可多次买卖

124.二叉树最大路径和，maxPathSum
数据结构：调用栈
算法：深度优先遍历dfs
思路：返回左右子树和的最大值，供上层节点使用

125.是否是回文串，isPalindrom
数据结构：双指针
算法：中心反向而行

127.单词接龙，ladderLength
数据结构：图 + 队列
算法：宽度优先搜索
思路：通过优化建图，引入“词根”减少建图的时间复杂度，然后利用”队列“进行宽度优先遍历算法，计算路径长度。

128.最长连续序列，longestConsecutive
数据结构：哈希表 or 左右子树法
思路1：第一遍构造哈希表，第二遍判断是否为起点，然后自增遍历，找寻最长连续序列
思路2：类比二叉树路径和，计算和更新左右子树连续序列长度

130.被围绕的区域，solve
数据结构：二维数组
算法：深度优先遍历 or 宽度优先遍历
思路：先用深度优先遍历，把跟边界联通的’O‘标记成’A'，然后，把'O'改为'X'

131.分割回文子串，partition
数据结构：数组
算法：深度优先遍历
思路：通过指针和数组，不断地分割字符串，判定分割后的子串是否是回文串，并递归处理，最后将结果返回

134.加油站
算法：动态规划 or 贪心算法
思路1：动态规划：dp记录当前剩余油量，负数时重新记录起始位置和油量，当再次走到起始位置时，判定油量情况，返回结果
思路2：贪心：能通过加油站，肯定要求：（1）总的净油量为正，可以不断累加净值最后判定；（2）每时每刻的净油量为正，那就要求起始位置必须从总净油量最少的地方开始。于是得姐。

136.只出现一次的数字，singleNumber
数据结构：
算法：异或

138.复制带随机指针的链表
数据结构：链表 + 哈希表
算法：哈希表存储新旧链表对应节点的映射关系，便于复制随机指针

139.单词拆分，wordBreak
数据结构：哈希表
算法：动态规划
思路：将问题拆解成子问题优化，判断最后一个”单词“在不在词典中，如果在，问题就变成，上一个单词在不在词典中了

140.单次拆分2
数据结构：哈希表
算法：动态规划 or 递归
思路：类比139题，将单词表存储哈希表中，对单词进行拆分判定是否在哈希表中，如果在就拼接新的单词到末尾。当然这一过程也可以用递归。

141.环形链表，hasCycle
数据结构：快慢指针
算法：快慢指针法
思路：快慢指针是否相交，相交后两指针位置距离正好等于链表环的长度，将慢指针从头开始，快慢指针同步前行，相交点即是环的入口

142.环形链表2，detectCircle
数据结构：快慢指针
算法：快慢指针法
思路：快慢指针是否相交，相交后两指针位置距离正好等于链表环的长度，将慢指针从头开始，快慢指针同步前行，相交点即是环的入口


146.LRU缓存，LRUCache
数据结构：双向链表 + 哈希表
算法：LRU算法
addToHead(), moveToHead(), removeNode(), removeTail()

148.排序链表，sortList
数据结构：链表 + 快慢指针
算法：归并分治算法
思路：快慢指针进行二分，归并进行合并链表

149.直线上最多的点数
数据结构：哈希表
算法：本质上是找相同斜率最多的点，那么可以对斜率进行分组统计，斜率如何表示呢，可以对delta_x, delta_y进行化简（最大公约数，再哈希），这样就得到斜率的表示。统计斜率的的节点数即可。当当前最多的节点数已经最大了，即剩余的节点数还没有当前同一个斜率的节点数多，那么后续节点也就没有处理的必要了，剪枝退出，返回答案。

152.乘积最大子数组，maxProduct
数据结构：数组
算法：动态规划
思路：维护两个动态规划数组，一个表示较大乘积，一个表示较小乘积

155.最小栈，MinStack
数据结构：栈
算法：迭代
思路：维护两个栈，一个用于存储栈元素一个用于存储最小值

160.相交链表，getIntersectionNode
数据结构：链表
算法：双指针迭代
思路：当两个指针不等时循环遍历，走到链表末尾时互换指针，保证两个指针最多只走l1 + l2步；
退出循环时若两个指针都为null，则不想交，否则即为相交节点

169.多数元素，majorityElement
数据结构：哨兵指针和计数器
算法：哨兵法
思路：遇到相同元素时+1，不相同元素时，计数器-1，这样做的思路是：对于多数元素问题，消除两个不同元素，不改变问题的结果。
同理：个数超过n/3的元素，也是可以通过两个哨兵的方法找出来

198.打家劫舍，rob
数据结构：数组
算法：动态规划
思路：两个动态规划数组，分别表示偷与不偷的收益

200.岛屿数量，numIslands
数据结构：二维数组自身状态标记（无需开辟新空间）+ 队列
算法：宽度优先遍历bfs or 深度优先遍历dfs
思路1：用队列queue进行宽度遍历，遍历后将值标记为’0‘，避免重复遍历，计算遍历的深度，即岛屿的个数。
思路2：对dfs深度遍历，被遍历过的值标记为0，计算岛屿数

206.反转链表，reserveList
数据结构：链表指针
算法；迭代 or 递归dfs
思路1：指针pre，cur，next，改变链表的方向
思路2：递归调用
node = reserve(head->next);
head->next->next = head;
head->next = nullptr;

dfs图示：
head -×-> next <- node <- tail
  ^--------|

207.课程表，canFinish
数据结构：哈希表 + 队列queue or 数组
算法：宽度优先遍历bfs or 深度优先遍历dfs（即Floyd判圈算法）
思路1：bfs，用哈希表统计每个课程的入度，将入度为零的课程放入队列中，依次处理队列中的课程，并对下游课程入度减1，如果为0，则放入队列，当所有课程都处理完了，返回true，否则返回false。
思路2：dfs：首先，哈希表构造课程的”边“依赖关系，为递归调用做准备，数组为状态表，判断是否有环路，无有则把课程放入结果集中，最后判断课程是否全部处理完成。

208.实现Trie树，Trie
数据结构：数组（多叉树的类）
算法：多叉树 + 迭代
思路：迭代插入和搜索

215.数组中第K大元素，findKthLargest
数据结构：数组 + 快排指针
算法：快排 or 堆排

221.最大正方形，maximalSquare
数据结构：二维数组
算法：动态规划
思路：dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])

226.翻转二叉树，invertTree
数据结构：二叉树
算法：深度优先遍历dfs

229.多数元素2（大于n/3的数），majorityElement
数据结构：两个哨兵
算法：贪心
思路：剔除三个不相同的数，不改变问题的结果

234.回文链表，isPalidrom
数据结构：链表 + 快慢指针
算法：快慢指针 + 反转链表
思路：快慢指针找出中点，然后翻转链表，比较是否相等，最后将翻转过的链表在翻转回去。

236.二叉树的最近公共祖先，lowestCommonAncester
数据结构：二叉树
算法：深度优先遍历dfs
思路：遇到p或q则返回该节点，如果孩子节点分别是p和q则返回root节点，都不是则返回nullptr
（保证树上要么是p，要么是q，要么是他们的祖先）

238.除自身以外数组的乘积，productExceptSelf
数据结构：数组
算法：动态规划
思路：利用输出数组作为动态规划的dp数组，第一遍计算得到左边的乘积，第二遍计算得到右边的乘积


239.滑动窗口最大值，maxSlidingWindow
数据结构：单调数组 or
算法1：每次滑动时，先与队列尾部元素比较，弹出较小的，最后判定队列首元素的失效性，然后去队首即为滑窗最大值。
算法2：将数组按滑窗大小进行分段，每个位置滑窗的最大值，由其滑窗前向的最大值和滑窗后向的最大值决定

240.搜索二维数组，searchMatrix
数据结构：二维数组
算法：二分，向上或向右

279.完全平方数，numSquares
数据结构：数组（字典）
算法：动态规划（子问题优化）

283.移动零，moveZero
数据结构：数组 + 双指针
算法：一个指针前进，一个指针指向左侧0的边界位置

287.寻找重复数，findDuplicate
数据结构：数组
算法1：+n置标志位
算法2：Floyd判圈算法（类似寻找有环链表、课程表问题）

297.二叉树的序列化和反序列化，Codec
数据结构：二叉树 + 字符串 + 队列
算法：宽度优先遍历：按照中序遍历进行序列化，使用队列queue进行反序列化

300.最长递增子序列，lengthOfLIS
数据结构：单调栈
算法：利用单调栈维护递增数组，更新单调栈时，使用二分查找可以提高查询效率

301.删除无效括号数，removeInvalidParentheses
数据结构：字符串 + 计数器
算法：深度优先遍历dfs：用计数器统计待删除的左右括号数，递归调用执行删除任务

309.最佳买卖股票时机含冷冻期，maxProfit
数据结构：数组或数字
算法：动态规划，买的收益、卖的收益、什么也不操作的收益

312.戳气球，maxCoins
数据结构：数组
算法：动态规划，三维遍历，从戳气球逆向求解

322.零钱兑换，coinChange
数据结构：二维数组
算法：动态规划
dp[i] = min(dp[i], dp[i - coin] + 1)

337.打家劫舍，rob
动态规划

338.比特位计数，countBits
数据结构：数组
算法：动态规划
思路1：与运算不停消除最低有效位，并计数
思路2：记录最高有效位（即n&(n-1) == 0, high=n

347.前k个高频元素，topKFrequent
数据结构：哈希表
算法：先统计计数，然后快排，找到第k大的元素

394.字符串解码，stringDecode
数据结构：字符串，栈
算法：利用栈或深度优先遍历dfs算法

399.除法求值，calcEquation
数据结构：哈希表 + 二维数组（并查集）
算法1：宽度优先遍历bfs
算法2：Floyd算法
算法3：并查集
思路1：利用队列queue，进行宽度优先遍历，当找到的子节点与被除数相等时，即有除法解
思路2：Floyd，构建图关系数据结构，通过Floyd算法预先计算节点之间的除法关系，然后计算除法
思路3：构造并查集，边查边更新节点的关系和权值

406.根据身高重建队列，reconstructQueue
数据结构：二维数组
算法：排序
思路1：从大到小排序
（1）预排序，按照身高从大到小、按照人数从小到大排序
（2）根据人数，在相应位置上直接插入即可
因为从大到小排序，后插入的身高低的，会改变右侧已插入身高高的元素的位置，但不会影响”人数关系“

思路2：从小到大排序
（1）预排序，按照身高从小到大，人数从大到小排序
（2）按人数遍历空位去插入
因为这样先插入身高低的，后插入身高高的，不会影响”人数关系“

416.分割等和子集，canPartition
数据结构：数组
算法：动态规划
思路：分割等和，即找寻能组成和为target = tsum / 2的子集，使用动态规划，从右往左找即可（避免数字被重复选取）

437.路径总和，pathSum
数据结构：二叉树 + 哈希表
算法：深度优先遍历 + 前缀和记忆
思路：用前缀和记录，二叉树深度遍历过程中的和，当前缀和 + target = tsum时，即有满足和为target的路径

438.找到字符串中所有字母异位词，findAnagrams
数据结构：字符串 + 哈希表
算法：迭代
思路：用一个哈希表计数器，记录待查找的字母异位词个字母的个数，然后遍历字符串去比较是否满足，如是则放入结果中。

448.找到所有数组消失的数字，findDisappearedNumbers
数据结构：数组
算法：加n取余法

461.汉明距离，hammingDistance
数据结构：二进制
算法：异或 + 二进制计数法

494.目标和，findTargetSumWays
数据结构：数组
算法：动态规划
思路：因为本题的目标和，是可加可减的，所以本质上是求new target = tsum - target。然后使用动态规划即可，类比416题。

538.把二叉搜索树转换成累加树，convertBST
数据结构：二叉树
算法：深度优先遍历
思路：右根左遍历（逆中序遍历）

543.二叉树的直径，diameterOfBinaryTree
数据结构：二叉树 + 队列
算法：深度优先遍历 or 宽度优先遍历


560.和为k的子数组，subarraySum
数据结构：数组 + 哈希表
算法：前缀和算法
思路：类比437题二叉树的路径总和，通过前缀和哈希表维护历史累加的和，当curSum = k + preSum时，即找到和为k的连续数组了。

581.最短无序子数组，findUnsortedSubarray
数据结构：数组
算法：从左往右找到波峰，从右往左找到波谷，然后再与波谷、波峰比较，找到无序的起始点。

617.合并二叉树，mergeTrees
数据结构：二叉树
算法：深度优先遍历

621.任务调度器，leastInterval
数据结构：数组 + 哈希表
思路：
（1）构造任务下次执行时间（数组）和任务剩余任务数（数组）
（2）执行任务的策略是：最近能执行的任务中剩余任务数最多的任务，所以：
（2.1）找出最近任务能执行的时间
（2.2）在最近能执行的时间内找出任务数最多的任务
（3）更新任务状态。

647.回文子串，countSubstrings
数据结构：字符串
算法：迭代
思路：分别以(i,i)和（i，i+1)为中心搜寻回文子串，记录个数

739.每日温度，dailyTemperatures
数据结构：数组 + 单调栈
算法：单调栈计算边界法
思路：用单调递减栈维持还没有找到右边界的左数，找到后依次弹出，并记录弹出左数的右边界
